function [output] = MotorUnitModel_v2(t,U,modelParameter,Fs)

N_MU = modelParameter.N; %number of motor unit
i_MU = 1:N_MU; %motor unit identification index
RR_MU = modelParameter.RR; %range of recruitment in unit of fold
a_MU = log(RR_MU)/N_MU; %coefficient to establish a range of threshold values
RTE_MU = exp(a_MU*i_MU); %recruitment threshold excitation
MFR_MU = modelParameter.MFR; %minimum firing rate constant for all motoneurons
g_e_MU = modelParameter.g_e; %missing parameter from the paper
PFR1_MU = modelParameter.PFR1; %the peak firing rate of the first recruited motoneuron in unit of impulse/sec
PFRD_MU = modelParameter.PFRD; %the desired difference in peak firing rates between the first and last units in unit of impulse/sec
RTEn_MU = exp(a_MU*N_MU); %recruitment threshold of the last motor unit
PFR_MU = PFR1_MU - PFRD_MU * (RTE_MU./RTEn_MU); %peak firing rate
PFRn_MU = PFR1_MU - PFRD_MU; %peak firing rate of the last motor unit
Emax_MU = RTEn_MU + (PFRn_MU - MFR_MU)/g_e_MU; %maximum excitatory input
cv_MU = modelParameter.cv; %ISI variability as per coefficient of variation (=mean/SD)

RP_MU = modelParameter.RP; %range of twich force across motor untis in unit of fold
b_MU = log(RP_MU)/N_MU; %coefficient to establish a range of twich force values
P_MU = exp(b_MU*i_MU); %force generated by a motor unit as a function of its recruitment threshold
T_L_MU = modelParameter.T_L; %the longest duration contraction time desired for the pool in unit of ms
RT_MU = modelParameter.RT; % range of contraction time in unit of fold
c_MU = log(100)/log(RT_MU); %coefficient to establish a range of contraction time values
T_MU = (T_L_MU.* (1./P_MU).^(1/c_MU))./1000; %contraction time
%P_amp = modelParameter.P_amp;
%P_MU = exp(b_MU*i_MU)*P_amp; %force generated by a motor unit as a function of its recruitment threshold
P_MU = exp(b_MU*i_MU);
t_twitch = 0:1/Fs:1;
twitch = zeros(N_MU,length(t_twitch));

spikeTrain = cell(1,N_MU);
force = cell(1,N_MU);
for j = 1:N_MU
    twitch(j,:) =  P_MU(j).*t_twitch./T_MU(j).*exp(1-t_twitch./T_MU(j));
    spikeTrain{j} = zeros(1,length(t));
    force{j} = zeros(1,length(t));
end


spike_time = cell(1,N_MU);
FR_MU = cell(1,N_MU);

E = U*Emax_MU;

parfor n = 1:N_MU
    for i = 1:length(t)
        FR_MU{n} = g_e_MU.*(E(i) - RTE_MU(n)) + MFR_MU;
        if FR_MU{n} <  MFR_MU
            FR_MU{n} = 0;
        elseif FR_MU{n} >= PFR_MU(n)
            FR_MU{n} = PFR_MU(n);
        end
        spike_train_temp = zeros(1,length(t));
        if FR_MU{n} >  MFR_MU
            if ~any(spikeTrain{n}) % initial time
                spike_train_temp(i) = 1;
                spikeTrain{n} = spikeTrain{n} + spike_train_temp;
                mu = 1/FR_MU{n};
                Z = randn(1);
                Z(Z>3.9) = 3.9;
                Z(Z<-3.9) = -3.9;
                spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
                spike_time{n} = round(spike_time_temp) + i;
                StimulusRate = T_MU(n)*FR_MU{n};
                if StimulusRate > 0 && StimulusRate <= 0.4
                    g = 1;
                elseif StimulusRate > 0.4
                    S_MU = 1 - exp(-2*(StimulusRate)^3);
                    g = (S_MU/StimulusRate)/0.3;
                end
                force_temp = conv(spike_train_temp,g*twitch(n,:));
                force{n} = force{n}+ force_temp(1:length(t));
            else
                if spike_time{n} == i
                    spike_train_temp(i) = 1;
                    spikeTrain{n} = spikeTrain{n} + spike_train_temp;
                    mu = 1/FR_MU{n};
                    Z = randn(1);
                    Z(Z>3.9) = 3.9;
                    Z(Z<-3.9) = -3.9;
                    spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
                    spike_time{n} = round(spike_time_temp) + i;
                    
                    StimulusRate = T_MU(n)*FR_MU{n};
                    if StimulusRate > 0 && StimulusRate <= 0.4
                        g = 1;
                    elseif StimulusRate > 0.4
                        S_MU = 1 - exp(-2*(StimulusRate)^3);
                        g = (S_MU/StimulusRate)/0.3;
                    end
                    force_temp = conv(spike_train_temp,g*twitch(n,:));
                    force{n} = force{n}+ force_temp(1:length(t));
                elseif i > spike_time{n} + round(1/FR_MU{n}*Fs)
                    spike_train_temp(i) = 1;
                    spikeTrain{n} = spikeTrain{n} + spike_train_temp;
                    spike_time{n} = i;
                    StimulusRate = T_MU(n)*FR_MU{n};
                    if StimulusRate > 0 && StimulusRate <= 0.4
                        g = 1;
                    elseif StimulusRate > 0.4
                        S_MU = 1 - exp(-2*(StimulusRate)^3);
                        g = (S_MU/StimulusRate)/0.3;
                    end
                    force_temp = conv(spike_train_temp,g*twitch(n,:));
                    force{n} = force{n} + force_temp(1:length(t));
                    %                 force_temp = twitch_function(twitch(n,:),force(n,i),T_MU(n),Fs);
                    %                 force(n,i:i+length(force_temp)-1) = force_temp;
                end
            end
        end
    end
end

output.Force = force;
output.SpikeTrain = spikeTrain;
% output.TotalForce = sum(force);
% output.FR = outputFR;
% output.g = outputG;

end
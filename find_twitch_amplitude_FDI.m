%--------------------------------------------------------------------------
% find_twitch_amplitude_FDI.m
% Author: Akira Nagamori
% Last update: 2/22/17
% ---Code descriptions-----
% Ojbective: find twitch amplitudes for each motor unit
%   - Define the theoretical MVC based on muscle length, density, mass and
%   physiological cross-sectional area
%       * this theoretical MVC should be obtained when all units are driven
%       at their respective tetanic frequecies
%   - Define fractional MVCs of each motor unit 
%       % Fractiona MVC = fraction of force contributed from each unit when
%       they are driven at their tetanic frequency 
%       % The fractional MVCs will be determined by fitting exponential
%       distribution with pre-difined ratio between largest and smallest
%       units
%   - Calculate mean tetanic force achieved by each unit at their tetanic
%   frequency using their respective twitch profiles with unitary
%   amplitude
%   - Calculate correction factor, i.e., the ratio of theoretical
%   fractional MVC to generated MVC using unitary twitch amplitude 
%
%--------------------------------------------------------------------------
close all
clear all
clc

%--------------------------------------------------------------------------
% F0 parameters
density = 1.06; % muscle density [g/cm^3]
L0 = 3; % optimal muscle length [cm]
mass = 0.0001; % muscle mass [kg]
PCSA = (mass*1000)/(density*L0); % PCSA of muscle
sigma = 22.4; % specific tension
F0 = PCSA*sigma;
N_MU = 120; % number of motor units
i_MU = 1:N_MU; % index for motor units

%--------------------------------------------------------------------------
% Peak tetanus parameter
RP_MU = 25; %range of peak tension across motor untis in unit of fold
b_MU = log(RP_MU)/N_MU; %coefficient to establish a range of twich force values
P_MU = exp(b_MU*i_MU); %force generated by a motor unit as a function of its recruitment threshold

PTi = P_MU./sum(P_MU)*F0;
Pi_half = PTi./2; % half of peak tetanus amplitude of each unit

%--------------------------------------------------------------------------
% Recruitment parameters
%   Find recruitment threshold for individual units using exponential fit
F_pcsa_slow = 0.5; % fractional PSCA of slow-twitch motor units (0-1)
[error, index_slow] = min(abs(cumsum(PTi) - F0*F_pcsa_slow)); % index for the largest motor unit clacified as slow-twitch
Ur = 0.6; % recruitment threshold for the last recruited motor unit
Ur_1 = 0.01; % reruitment threshold for the first unit
f_RT = fit([1 N_MU]',[Ur_1 Ur]','exp1');
coeffs_f_RT = coeffvalues(f_RT);
U_th = coeffs_f_RT(1)*exp(coeffs_f_RT(2)*i_MU); % the resulting recruitment threshold for individual units

%--------------------------------------------------------------------------
% Firing rate parameters
%   Find peak firing rates of individual units
%  In this formulation, the peak firing rate of a unit increases as
%  recruitment threshold increases (Loeb's formulation)
%  The minimum firing rate for individual units is constant as opposed to
%  Loeb's formulation
MFR_MU = 8; %muscle_parameter.MFR; %minimum firing rate constant for all motoneurons
PFR1_MU = 20; %the peak firing rate of the first recruited motoneuron in unit of impulse/sec
PFRD_MU = 30; %the desired difference in peak firing rates between the first and last units in unit of impulse/sec
RTEn_MU = U_th(end); %recruitment threshold of the last motor unit
PFR_MU = PFR1_MU + PFRD_MU * (U_th./RTEn_MU); %peak firing rate
FR_half = PFR_MU./2; % firing rate at which half of maximum tension is achieved

%--------------------------------------------------------------------------
% Contraction time and half relaxation time
%    Find contraction time and half relaxation time of individual units
%   Using Loeb's formulation that contraction time of individual units is
%   proportional to 1/FR_half (Brown & Loeb 2000 IV; Botterman et al., 1996)
CT_n = 20;
FR_half_n = FR_half(end);
CT = 1.5*(CT_n*FR_half_n)./FR_half;
CT = CT - (CT(end)-CT_n);
CT = CT/1000;
RT = CT;

%--------------------------------------------------------------------------
cv_MU = 0; %ISI variability as per coefficient of variation (=mean/SD)
Lce = 1;
Y = 1;
S = 0.96;
Af = 1;
Fs = 1000;
t_twitch = 0:1/Fs:1;
t_temp = 0:1/Fs:8;
t = 0:1/Fs:10;

count = 0;

testedUnits = [1 20 40 60 80 100 120]; % indeces for units tested
U = [zeros(1,Fs-1) 0:1/Fs:1 ones(1,6*Fs) -1*[0:1/Fs:1]+1 zeros(1,1*Fs)];

for k = 1:length(testedUnits)
    n = testedUnits(k);
            
    f_env = PFR_MU(n)/FR_half(n);
    if testedUnits(k) <= index_slow
        Af = Af_slow_function(f_env,Lce,Y);
        Af_cor = Af_slow_correction_function(f_env,Lce,Y);
    else
        Af = Af_fast_function(f_env,Lce,S);
        Af_cor = Af_fast_correction_function(f_env,Lce,S);
    end
    t_temp = 0:1/Fs:8;
    spikeTrain_temp = spikeTrainGenerator(t_temp,Fs,PFR_MU(n));
    spikeTrain = [zeros(1,1*Fs) spikeTrain_temp zeros(1,1*Fs)];
    [twitch_temp,~,~] = twitch_function(Af,Lce,CT(n),RT(n),Fs);
    twitch =  twitch_temp*Af_cor;
    force_temp = conv(spikeTrain,twitch);
    force = force_temp(1:length(t));    
        
    figure(1)  
    plot(t,force)
    hold on
    
    meanForce(k) = mean(force(5*Fs:7*Fs));
    ratio(k) = PTi(n)/meanForce(k);
    
end

% fit exponential curve to the relationship
x = testedUnits';
y = ratio';
f = fit(x,y,'exp1');
figure(4)
plot(f,x,y)
xlabel('Motor Unit Number')
ylabel('Ratio') 

cor_factor = feval(f,i_MU);

%%
function [twitch,T1,T2_temp] = twitch_function(Af,Lce,CT,RT,Fs)
T1 = CT*Lce^2+(CT*1/2)*Af;
T2_temp = (RT + (RT*1/2)*Af)/Lce;
T2 = T2_temp/1.68;
t_twitch = 0:1/Fs:1;
f_1 = t_twitch./T1.*exp(1-t_twitch./T1);
f_2 = t_twitch./T2.*exp(1-t_twitch./T2);

twitch = [f_1(1:round(T1*Fs+1)) f_2(round(T2*Fs+1):end)];
twitch = twitch(1:length(t_twitch));

end

function Af = Af_slow_function(force,L,Y)
a_f = 0.56;
n_f0 = 2.1;
n_f1 = 5;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(Y*force/(a_f*n_f))^n_f);
end

function Af = Af_fast_function(force,L,S)
a_f = 0.56;
n_f0 = 2.1;
n_f1 = 3.3;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(S*force/(a_f*n_f))^n_f);
end

function Af = Af_slow_correction_function(f_env,L,Y)
a_f = 0.5;
n_f0 = 2.01;
n_f1 = 5.16;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(Y*f_env/(a_f*n_f))^n_f);
Af = Af/f_env;
end

function Af = Af_fast_correction_function(f_env,L,S)
a_f = 0.52;
n_f0 = 1.97;
n_f1 = 3.28;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(S*f_env/(a_f*n_f))^n_f);
Af = Af/f_env;
end


function spikeTrain = spikeTrainGenerator(t,Fs,freq)

spikeTrain = zeros(1,length(t));
ISI = round(1/freq*Fs);
numSpikes = round(length(t)/ISI);
index = [1:numSpikes]*ISI;
index(index>length(t)) = [];
spikeTrain(index) = 1;
spikeTrain(1) = 1;

end
%--------------------------------------------------------------------------
% modelTesting_MototUnit_v2.m
% Author: Akira Nagamori
% Last update: 12/20/207
% Objective: Test activation frequency relationship of motor unit model
%--------------------------------------------------------------------------

close all
clear all
clc

%--------------------------------------------------------------------------
% muscle architecture parameters

density = 1.06; % muscle density [g/cm^3]
L0 = 6.8; % optimal muscle length [cm]
mass = 0.15; % muscle mass [kg]
PCSA = (mass*1000)/(density*L0); % PCSA of muscle
sigma = 22.5; % specific tension
F0 = PCSA*sigma;
N_fibers = 272850; % number of muscle fibers
N_MU = 450; % number of motor units
i = 1:N_MU; % index for motor units

%--------------------------------------------------------------------------
% Find peak tetanus amplitude
RP_MU = 30; %range of peak tension across motor untis in unit of fold
b_MU = log(RP_MU)/N_MU; %coefficient to establish a range of twich force values
P_MU = exp(b_MU*i); %force generated by a motor unit as a function of its recruitment threshold

fPCSA = PCSA/N_fibers; % fractional PCSA occupied by a single fiber
ni = P_MU/sum(P_MU)*N_fibers; % innervation number of each unit assuming that peak tension generated by each unit is proportional to innervation number
Pi = sigma*fPCSA*ni; % peak tetanus amplitude of each unit

load('cor_factor')
Pi = Pi.*cor_factor';
%-------------------------

F_pcsa_slow = 0.5; % fractional PSCA of slow-twitch motor units (0-1)
[error, index_slow] = min(abs(cumsum(Pi) - F0*F_pcsa_slow));

% Find recruitment threshold for individual units using exponential fit
Ur = 0.8; % recruitment threshold for the lastly recruited motor unit
Ur_1 = 0.01; % reruitment threshold for the first unit
f_RT = fit([1 N_MU]',[Ur_1 Ur]','exp1');
coeffs_f_RT = coeffvalues(f_RT);
U_th = coeffs_f_RT(1)*exp(coeffs_f_RT(2)*i); % the resulting recruitment threshold for individual units

%--------------------------------------------------------------------------
% Find peak firing rates of individual units
%  In this formulation, the peak firing rate of a unit increases as
%  recruitment threshold increases (Loeb's formulation)
%  The minimum firing rate for individual units is constant as opposed to
%  Loeb's formulation

MFR_MU = 8; %muscle_parameter.MFR; %minimum firing rate constant for all motoneurons
g_e_MU = 1; %missing parameter from the paper

PFR1_MU = 20; %the peak firing rate of the first recruited motoneuron in unit of impulse/sec
PFRD_MU = 40; %the desired difference in peak firing rates between the first and last units in unit of impulse/sec
RTEn_MU = U_th(end); %recruitment threshold of the last motor unit
PFR_MU = PFR1_MU + PFRD_MU * (U_th./RTEn_MU); %peak firing rate
FR_half = PFR_MU./2; % firing rate at which half of maximum tension is achieved

%--------------------------------------------------------------------------
% Find contraction time of individual units
%   Using Loeb's formulation that contraction time of individual units is
%   proportional to 1/FR_half (Brown & Loeb 2000 IV; Botterman et al., 1996)
CT_n = 11;
FR_half_n = FR_half(end);
CT = 3*(CT_n*FR_half_n)./FR_half;
CT = CT - (CT(end)-CT_n);
CT = CT/1000;
RT = CT.*1.3719;
cv_MU = 0.1; %ISI variability as per coefficient of variation (=mean/SD)

Fs = 1000;
t_twitch = 0:1/Fs:1;
twitch = zeros(N_MU,length(t_twitch));

for j = 1:N_MU
    twitch(j,:) =  Pi(j).*t_twitch./CT(j).*exp(1-t_twitch./CT(j));
end
%%
t = 0:1/Fs:3;
amp_temp = 0:0.1:1;
for k = 1 %:length(amp_temp)
    amp = 1; %amp_temp(k);
    
    U = [zeros(1,1*Fs) amp*ones(1,1*Fs),zeros(1,1*Fs+1)];
    
    %--------------------------------------------------------------------------
    % initialize parameters
    Y_af_temp = 0;
    S_af_temp = zeros(N_MU,1);
    Lce = 1;
    Vce = 0;
    
    spike_time = zeros(N_MU,1);
    spike_train = zeros(N_MU,length(t));
    force = zeros(N_MU,length(t));
    FR_MU = zeros(N_MU,length(t));
    S_af = zeros(N_MU,length(t));
    Y_af = zeros(N_MU,length(t));
    f_int = zeros(N_MU,1);
    f_int_dot = zeros(N_MU,1);
    f_eff = zeros(N_MU,1);
    f_eff_dot = zeros(N_MU,1);
    Af = zeros(N_MU,1);
    Tf = zeros(N_MU,1);
    
    Outputfenv = zeros(N_MU,length(t));
    Outputfint = zeros(N_MU,length(t));
    Outputfeff = zeros(N_MU,length(t));
    OutputYaf = zeros(N_MU,length(t));
    OutputSaf = zeros(N_MU,length(t));
    OutputAf = zeros(N_MU,length(t));
    OutputTf = zeros(N_MU,length(t));
    %--------------------------------------------------------------------------
    for i = 1:length(t)
        FR_MU(:,i) = (PFR_MU-MFR_MU)./(1-U_th).*(U(i)-U_th) + MFR_MU;
        FR_MU(FR_MU<8) = 0;
        f_env = FR_MU(:,i)./FR_half';
        Outputfenv(:,i) = f_env;
        % Yielding
        Y_af_temp = yield_function(Y_af_temp,Vce,Fs);
        Y_af(1:index_slow,i) = Y_af_temp;
        
        % Sag
        for n_sag = index_slow+1:N_MU
            S_af_temp(n_sag) = sag_function(S_af_temp(n_sag),f_eff(n_sag),Fs);
            S_af(n_sag,i) = S_af_temp(n_sag);
        end
        for n_f = 1:N_MU
            [f_int(n_f),f_int_dot(n_f),Tf(n_f)] = f_function(f_int(n_f),f_env(n_f),f_env(n_f),f_eff_dot(n_f),CT(n_f),RT(n_f),Af(n_f),Lce,Fs);
            [f_eff(n_f),f_eff_dot(n_f),Tf(n_f)] = f_function(f_eff(n_f),f_int(n_f),f_env(n_f),f_eff_dot(n_f),CT(n_f),RT(n_f),Af(n_f),Lce,Fs);
            if n_f <= index_slow
                Af(n_f) = Af_slow_function(f_eff(n_f),Lce,Y_af(n_f,i));
                OutputAf(n_f,i)= Af(n_f);
            else
                Af(n_f) = Af_fast_function(f_eff(n_f),Lce,S_af(n_f,i));
                OutputAf(n_f,i)= Af(n_f);
            end
        end
        for n = 1:length(find(FR_MU(:,i)>=MFR_MU)) % loop through motor units whose firing rate is greater than minimum firing rate defined by the user
            if FR_MU(n,:) > PFR_MU(n)
                FR_MU(n,:) = PFR_MU(n);
            end
           
            spike_train_temp = zeros(1,length(t));
            if ~any(spike_train(n,:)) % when the motor unit fires at the first time
                spike_train(n,i) = 1; % add a spike to the vector
                spike_train_temp(i) = 1;
                mu = 1/FR_MU(n,i);
                Z = randn(1);
                Z(Z>3.9) = 3.9;
                Z(Z<-3.9) = -3.9;
                spike_time_temp = (mu + mu*cv_MU*Z)*Fs;
                spike_time(n) = round(spike_time_temp) + i;
                
                %force_temp = conv(spike_train_temp,g.*twitch(n,:)).*FL_temp.*FV_temp.*Af;
                twitch_temp =  Pi(n).*t_twitch./Tf(n).*exp(1-t_twitch./Tf(n));
                force_temp = conv(spike_train_temp,twitch_temp);
                force(n,:) = force(n,:) + force_temp(1:length(t));
            else
                if spike_time(n) == i % when the motor unit fires
                    spike_train(n,i) = 1;
                    spike_train_temp(i) = 1;
                    % update mean firing rate of the motor unit given the
                    % current value of input
                    mu = 1/FR_MU(n,i); % interspike interval
                    Z = randn(1);
                    Z(Z>3.9) = 3.9;
                    Z(Z<-3.9) = -3.9;
                    spike_time_temp = (mu + mu*cv_MU*Z)*Fs; % interspike interval
                    spike_time(n) = round(spike_time_temp) + i; % spike time of next spike
                    
                    
                    %force_temp = conv(spike_train_temp,g.*twitch(n,:)).*FL_temp.*FV_temp.*Af;
                    twitch_temp =  Pi(n).*t_twitch./Tf(n).*exp(1-t_twitch./Tf(n));
                    force_temp = conv(spike_train_temp,twitch_temp);
                    force(n,:) = force(n,:) + force_temp(1:length(t));
                elseif i > spike_time(n) + round(1/FR_MU(n,i)*Fs)
                    spike_train(n,i) = 1;
                    spike_train_temp(i) = 1;
                    spike_time(n) = i;
                    mu = 1/FR_MU(n,i); % interspike interval
                    Z = randn(1);
                    Z(Z>3.9) = 3.9;
                    Z(Z<-3.9) = -3.9;
                    spike_time_temp = (mu + mu*cv_MU*Z)*Fs; % interspike interval
                    spike_time(n) = round(spike_time_temp) + i; % spike time of next spike
                   
                    %force_temp = conv(spike_train_temp,g.*twitch(n,:)).*FL_temp.*FV_temp.*Af;
                    twitch_temp =  Pi(n).*t_twitch./Tf(n).*exp(1-t_twitch./Tf(n));
                    force_temp = conv(spike_train_temp,twitch_temp);
                    force(n,:) = (force(n,:) + force_temp(1:length(t)));
                end
            end
            if n <= index_slow
                FL_temp = FL_slow_function(Lce);
                if Vce > 0
                    FV_temp = FVecc_function(Lce,Vce);
                else
                    FV_temp = FVcon_function(Lce,Vce);
                end
            else
                FL_temp = FL_fast_function(Lce);
                if Vce > 0
                    FV_temp = FVecc_fast_function(Lce,Vce);
                else
                    FV_temp = FVcon_fast_function(Lce,Vce);
                end
            end
            force(n,i) = force(n,i)*FL_temp*FV_temp;           
        end
        force(:,i) = force(:,i).*Af;
        OutputTf(:,i) = Tf;
        Outputfint(:,i) = f_int;
        Outputfeff(:,i) = f_eff;
    end
    
    %%
    totalForce = sum(force);
    maxTotalForce = mean(totalForce(1.8*Fs:2*Fs));
    halfTotalForce = maxTotalForce/2;
    CoV(k) = std(totalForce(1.8*Fs:2*Fs))/maxTotalForce;
    meanForce(k) = maxTotalForce; 
    CoV(k) 
    figure(1)
    subplot(2,1,1)
    plot(t,U)
    subplot(2,1,2)
    plot(t,totalForce)
    hold on
    hold on
    plot([t(1) t(end)],[maxTotalForce maxTotalForce],'k')
    hold on
    plot([t(1) t(end)],[halfTotalForce halfTotalForce],'r')
    xlabel('Time (s)')
    ylabel('Total Force (N)')
    
    %%
    testedUnit = 450;
    peak_f_eff = max(Outputfeff(testedUnit,:));
    half_f_eff = peak_f_eff/2;
    [error,loc] = min(abs(half_f_eff-Outputfeff(testedUnit,1*Fs:2*Fs)));
    t_0_50 = t(loc+1*Fs) - 1
    
    figure(2)
    subplot(3,1,1)
    plot(t,Outputfenv(testedUnit,:))
    xlabel('Time (s)')
    ylabel('f_{env}')
    hold on
    plot(t,Outputfint(testedUnit,:))
    hold on
    plot(t,Outputfeff(testedUnit,:))
    subplot(3,1,2)
    plot(t,OutputAf(testedUnit,:))
    xlabel('Time (s)')
    ylabel('Af')
    subplot(3,1,3)
    plot(t,force(testedUnit,:))
    xlabel('Time (s)')
    ylabel('Motor Unit Force (N)')
    
    
end
%%
function Y = yield_function(Y,V,Fs)
c_y = 0.35;
V_y = 0.1;
T_y = 0.2;

Y_dot = (1-c_y*(1-exp(-abs(V)/V_y))-Y)/T_y;
Y = Y_dot*1/Fs + Y;
end

function S = sag_function(S,f_eff,Fs)
if f_eff < 0.1
    a_s = 1.76;
else
    a_s = 0.96;
end
T_s = 0.043;
S_dot = (a_s-S)/T_s;
S = S_dot*1/Fs + S;
end

function Af = Af_slow_function(f_eff,L,Y)
a_f = 0.56;
n_f0 = 2.1;
n_f1 = 5;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(Y*f_eff/(a_f*n_f))^n_f);
end

function Af = Af_fast_function(f_eff,L,S)
a_f = 0.56;
n_f0 = 2.1;
n_f1 = 3.3;
n_f = n_f0 + n_f1*(1/L-1);
Af = 1 - exp(-(S*f_eff/(a_f*n_f))^n_f);
end

function [f_out,f_out_dot,Tf] = f_function(f_out,f_in,f_env,f_eff_dot,CT,RT,Af,Lce,Fs)
T_f1 = CT*3/4;
T_f2 = CT*1/4;
T_f3 = RT*3/4;
T_f4 = RT*1/4;

if f_eff_dot >= 0
    Tf = T_f1*Lce^2+T_f2*f_env;
else
    Tf = (T_f3 + T_f4*Af)/Lce;
end
f_out_dot = (f_in - f_out)/Tf;
f_out = f_out_dot*1/Fs + f_out;

end


function FL = FL_slow_function(L)
%---------------------------
% force length (F-L) relationship for slow-tiwtch fiber
% input: normalized muscle length and velocity
% output: F-L factor (0-1)
%---------------------------
beta = 2.3;
omega = 1.12;
rho = 1.62;

FL = exp(-abs((L^beta - 1)/omega)^rho);
end

function FL = FL_fast_function(L)
%---------------------------
% force length (F-L) relationship for fast-twitch fiber
% input: normalized muscle length and velocity
% output: F-L factor (0-1)
%---------------------------
beta = 1.55;
omega = 0.75;
rho = 2.12;

FL = exp(-abs((L^beta - 1)/omega)^rho);
end

function FVcon = FVcon_function(L,V)
%---------------------------
% concentric force velocity (F-V) relationship for slow-twitch fiber
% input: normalized muscle length and velocity
% output: F-V factor (0-1)
%---------------------------
Vmax = -7.88;
cv0 = 5.88;
cv1 = 0;

FVcon = (Vmax - V)/(Vmax + (cv0 + cv1*L)*V);
end

function FVcon = FVcon_fast_function(L,V)
%---------------------------
% concentric force velocity (F-V) relationship for fast-twitch fiber
% input: normalized muscle length and velocity
% output: F-V factor (0-1)
%---------------------------
Vmax = -9.15;
cv0 = -5.7;
cv1 = 9.18;

FVcon = (Vmax - V)/(Vmax + (cv0 + cv1*L)*V);
end

function FVecc = FVecc_function(L,V)
%---------------------------
% eccentric force velocity (F-V) relationship for slow-twitch fiber
% input: normalized muscle length and velocity
% output: F-V factor (0-1)
%---------------------------
av0 = -4.7;
av1 = 8.41;
av2 = -5.34;
bv = 0.35;
FVecc = (bv - (av0 + av1*L + av2*L^2)*V)/(bv+V);
end

function FVecc = FVecc_fast_function(L,V)
%---------------------------
% eccentric force velocity (F-V) relationship for fast-twitch fiber
% input: normalized muscle length and velocity
% output: F-V factor (0-1)
%---------------------------
av0 = -1.53;
av1 = 0;
av2 = 0;
bv = 0.69;
FVecc = (bv - (av0 + av1*L + av2*L^2)*V)/(bv+V);
end

function Fpe1 = Fpe1_function(L,V)
%---------------------------
% passive element 1
% input: normalized muscle length
% output: passive element force (0-1)
%---------------------------
c1_pe1 = 23;
k1_pe1 = 0.046;
Lr1_pe1 = 1.17;
eta = 0.01;

Fpe1 = c1_pe1 * k1_pe1 * log(exp((L - Lr1_pe1)/k1_pe1)+1) + eta*V;

end

function Fpe2 = Fpe2_function(L)
%---------------------------
% passive element 2
% input: normalized muscle length
% output: passive element force (0-1)
%---------------------------
c2_pe2 = -0.02;
k2_pe2 = -21;
Lr2_pe2 = 0.70;

Fpe2 = c2_pe2*exp((k2_pe2*(L-Lr2_pe2))-1);

end

function Fse = Fse_function(LT)
%---------------------------
% series elastic element (tendon)
% input: tendon length
% output: tendon force (0-1)
%---------------------------
cT_se = 27.8; %27.8
kT_se = 0.0047;
LrT_se = 0.964;

Fse = cT_se * kT_se * log(exp((LT - LrT_se)/kT_se)+1);

end